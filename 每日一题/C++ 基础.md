1. **C和C++有什么区别？**
   - C++是C的超集，支持面向对象编程（类、继承、多态等）。
   - C++支持异常处理、函数重载、运算符重载、模板（泛型编程）、命名空间等特性。
   - C++标准库比C标准库更丰富（如STL）。

2. **C语言的结构体和C++的有什么区别？**
   - 在C中，结构体（struct）只能包含数据成员，不能有函数成员（C99允许函数指针，但不能有普通函数）。
   - 在C++中，结构体可以包含数据成员和函数成员（方法），并且支持访问控制（默认public），也可以有构造函数和析构函数。实际上，C++中结构体和类（class）几乎相同，唯一区别是默认访问权限（结构体默认public，类默认private）。

3. **C语言的关键字static和C++的关键字static有什么区别？**
   - 在C和C++中，static关键字的基本作用相同：用于函数内部时，使变量在程序生命周期内存在（静态局部变量）；用于全局变量或函数时，限制其作用域为当前文件（内部链接）。
   - 在C++中，static还可以用于类的成员（静态成员变量和静态成员函数），表示该成员属于类本身，而不是类的实例。

4. **C++和Java有什么核心区别？**
   - 内存管理：C++手动/智能指针，Java自动垃圾回收。
   - 多重继承：C++支持，Java不支持（但支持接口的多继承）。
   - 指针：C++有指针，Java没有（但有引用，且不支持指针运算）。
   - 平台：C++编译为机器码，运行效率高，但跨平台需重新编译；Java编译为字节码，由JVM解释执行，跨平台性好。
   - 泛型：C++模板在编译时实例化，Java泛型通过类型擦除实现（运行时类型信息丢失）。
   - 其他：C++支持运算符重载、默认参数、全局变量和函数等，Java不支持。

5. **C++中，a和&a有什么区别？**
   - `a`：表示变量a的值。
   - `&a`：表示变量a的地址（即指向a的指针）。

6. **C++中，static关键字有什么作用？**
   - 静态局部变量：在函数内，变量在程序生命周期内存在，且只初始化一次。
   - 静态全局变量/函数：限制作用域为当前文件（内部链接）。
   - 静态成员变量：属于类，所有实例共享，需要在类外定义。
   - 静态成员函数：属于类，只能访问静态成员，没有this指针。

7. **C++中，#define和const有什么区别？**
   - `#define`：预处理指令，进行文本替换，不占用内存，没有类型检查。
   - `const`：定义常量，有类型，占用存储空间（通常），作用域规则与变量相同，编译器进行类型检查。

8. **静态链接和动态链接有什么区别？**
   - 静态链接：在编译时将库代码复制到可执行文件中。优点：独立运行；缺点：文件大，更新库需重新编译。
   - 动态链接：在运行时加载共享库。优点：节省内存和磁盘空间，多个程序共享，更新库无需重新编译程序；缺点：运行时依赖库的存在。

9. **变量的声明和定义有什么区别？**
   - 声明（declaration）：告诉编译器变量的类型和名字，不分配内存（例如：`extern int a;`）。
   - 定义（definition）：分配内存，可能初始化（例如：`int a;`或`int a=10;`）。
   - 注意：变量可以多次声明，但只能定义一次。

10. **typedef和define有什么区别？**
    - `typedef`：为已有类型定义别名，在编译阶段处理，有类型检查。
    - `#define`：预处理指令，进行文本替换，无类型检查，可以定义常量、宏等。

11. **final和override关键字**
    - `final`：用于类（表示不可被继承）或虚函数（表示不可被覆盖）。
    - `override`：用于虚函数，显式指明覆盖基类虚函数，编译器会检查是否真的覆盖。

12. **宏定义和函数有何区别？**
    - 宏：预处理阶段展开，文本替换，无类型检查，可能产生副作用（如多次计算参数），不占调用开销（但可能增加代码大小）。
    - 函数：运行时调用，有类型检查，不会产生宏的副作用，有调用开销（但可优化）。

13. **sizeof和strlen的区别**
    - `sizeof`：运算符，编译时计算，返回对象或类型的大小（字节数），包括数组中的`\0`。
    - `strlen`：函数，运行时计算，返回C风格字符串的长度（不包括`\0`）。

14. **简述strcpy、sprintf与memcpy的区别**
    - `strcpy`：复制字符串（遇到`\0`停止），不检查目标缓冲区大小。
    - `sprintf`：格式化输出到字符串，不检查缓冲区溢出。
    - `memcpy`：复制指定字节数的内存块（不关心内容，包括`\0`也会复制）。
    - 共同点：都不检查目标缓冲区大小，可能导致溢出。

15. **结构体可以直接赋值吗？**
    - C中：可以，但仅限于简单结构体（不含指针等），是浅拷贝。
    - C++中：可以，编译器会生成默认的赋值运算符，执行成员逐个赋值（浅拷贝）。如果结构体包含指针，需要深拷贝，应自定义赋值运算符。

16. **volatile有什么作用？**
    - 告诉编译器该变量可能被意外修改（如硬件、中断、多线程），避免编译器优化（如缓存到寄存器），每次访问都从内存读取。

17. **一个参数可以既是const又是volatile吗？**
    - 可以。`const`表示程序不应修改它，`volatile`表示它可能被外部改变（如只读硬件寄存器）。

18. **全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？**
    - 全局变量：定义在函数外，整个程序可见，生命周期为整个程序运行期，存储在静态存储区（数据段）。
    - 局部变量：定义在函数内，作用域为函数内，生命周期为函数执行期，存储在栈上。
    - 编译器通过定义位置区分，并生成不同的存储分配代码。操作系统在加载程序时分配全局变量空间，运行时栈由程序管理局部变量。

19. **什么是C++中的指针和引用？它们有什么区别？**
    - 指针：存储地址的变量，可以重新赋值，可以为空，支持指针运算。
    - 引用：别名，必须初始化，不能重新绑定，不能为空，更安全。
    - 区别：引用更简洁，但指针更灵活。

20. **数组名和指针（这里为指向数组首元素的指针）区别？**
    - 数组名：代表整个数组，但大多数情况下退化为指向首元素的指针。`sizeof(数组名)`返回整个数组的大小。
    - 指针：存储地址的变量，`sizeof(指针)`返回指针本身大小（如4或8字节）。
    - 数组名不能赋值（不能改变指向），指针可以。

21. **一个指针占用多少字节？**
    - 取决于系统架构：32位系统为4字节，64位系统为8字节。

22. **什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？**
    - 智能指针：类模板，自动管理动态内存，防止内存泄漏。
    - 作用：自动释放内存，简化资源管理。
    - 种类：
        - `unique_ptr`：独占所有权，不可复制，可移动。
        - `shared_ptr`：共享所有权，引用计数。
        - `weak_ptr`：弱引用，不增加引用计数，解决循环引用。
        - `auto_ptr`：已废弃（C++11前），有所有权转移问题。

23. **shared_ptr是如何实现的？**
    - 通过引用计数实现。每个`shared_ptr`对象内部包含两个指针：一个指向管理的对象，一个指向控制块（包含引用计数、弱引用计数等）。当引用计数为0时，自动删除对象。

24. **右值引用有什么作用？**
    - 用于实现移动语义（避免不必要的拷贝）和完美转发。允许资源从临时对象（右值）转移到新对象，提高效率。

25. **悬挂指针与野指针有什么区别？**
    - 悬挂指针（Dangling Pointer）：指向已被释放的内存的指针。
    - 野指针（Wild Pointer）：未初始化或指向无效地址的指针。

26. **指针常量与常量指针区别**
    - 指针常量（Pointer to Constant）：`const int* p` 或 `int const* p`，指向的内容不可变，指针可变。
    - 常量指针（Constant Pointer）：`int* const p`，指针本身不可变（指向固定），内容可变。
    - 指向常量的常量指针：`const int* const p`，都不可变。

27. **如何避免“野指针”？**
    - 初始化指针（如置为`nullptr`）。
    - 释放内存后立即置空。
    - 避免返回局部变量的地址。
    - 使用智能指针。

28. **句柄和指针的区别和联系是什么？**
    - 指针：直接内存地址。
    - 句柄：抽象引用，可能是指针的索引或标识符（如操作系统资源句柄）。
    - 联系：句柄通常通过指针实现，但提供了一层间接性，更安全（如系统可重定位资源）。

29. **说一说extern“C”**
    - 用于C++代码中调用C语言编写的函数或变量。告诉编译器按C语言的命名和调用约定编译，避免名称修饰（name mangling）问题。

30. **对c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr的理解**
    - `shared_ptr`：共享所有权，引用计数，可复制，线程安全（引用计数原子操作）。
    - `unique_ptr`：独占所有权，不可复制，可移动，轻量高效。
    - `weak_ptr`：配合`shared_ptr`使用，解决循环引用，不控制对象生命周期。
    - `auto_ptr`：旧版，有缺陷（所有权转移导致原指针悬空），已废弃。
