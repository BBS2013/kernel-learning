# new和delete必须配对使用：new[]和delete[]如何知道数组长度？

## 内存分配机制
当使用 `new[]` 分配数组内存时，`new[]` 会为数组分配一块连续的内存空间，并在内存块的起始位置（数组首地址之前）额外分配一段空间，用于存储数组的长度信息。这部分空间通常被称为元信息（metadata）。
## 内存布局示例
最终的内存布局如下：
```
[元信息（数组长度）][数组元素 0][数组元素 1][数组元素 2]
```
## delete[]的工作原理
当调用 `delete[]` 时，`delete[]` 会从数组首地址之前读取元信息中的数组长度，从而确定需要释放的内存范围以及调用析构函数的次数。具体步骤如下：
1. **获取元信息**：`delete[]` 会将传入的指针（数组首地址）向前偏移，读取元信息中存储的数组长度。
2. **调用析构函数**：根据数组长度，依次调用数组中每个元素的析构函数。
3. **释放内存**：将整个内存块（包括元信息和数组元素）归还给操作系统。


# C++为什么需要类型转换？
- static_cast: 基本类型转换
- dynamic_cast: 类层次间的安全下行转换 ，将父类的指针或引用转换为自雷的指针或引用。
父类的必须要有需函数，因为dynamic_cat在运行时检查，需要运行时类型信息（RTTI），而RTTI存储在虚函数表中。
- const_cast: const限定符移除
- reinterpret_cast: 低层次重新解释

# 多态
 - 当使用父类指针指向子类对象时（无论是隐式转换、static_cast还是dynamic_cast），通过父类指针调用虚函数，会调用该对象的实际类型（子类）的虚函数版本。这就是多态。

 - 如果子类重写了父类的虚函数，那么通过父类指针调用该函数时，会调用子类的版本。如果子类没有重写，那么就会调用父类的版本。

 # static_cast 将子类指针向上转型为父类指针后，函数调用的行为取决于函数是否为虚函数
 1. 虚函数调用（多态行为） // 调用子类重写的虚函数 ，优先调用子类重写的版本（如果存在）
 2. 非虚函数调用（静态绑定） // 调用父类的函数版本，子类的同名函数会被隐藏