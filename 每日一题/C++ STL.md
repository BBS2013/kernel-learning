# 1. 请解释vector容器和它的特点。
 vector容器是C++ STL中的动态数组，具有以下特点：
- 支持随机访问（O(1)时间复杂度）
- 自动管理内存，动态扩容
- 在尾部插入/删除元素效率高（O(1)）
- 在中间插入/删除元素效率较低（O(n)）
- 连续内存存储，支持迭代器遍历
 
# 2. vector如何保证元素的连续存储？
`std::vector` 是 C++ 标准模板库（STL）中的一部分，它提供了一个动态数组的实现。为了保证元素的连续存储，`std::vector` 在内部使用一个单一的、连续的内存块来存储其元素。以下是 `std::vector` 如何确保这一点的一些关键点：
1. **初始化时分配内存**：当创建一个 `std::vector` 时，它会根据给定的大小或者默认构造函数决定的大小，请求分配一块足够大的连续内存空间来容纳初始数量的元素。
2. **自动扩容机制**：当你向 `std::vector` 中添加超过其当前容量的元素时，它需要更多的空间。此时，`std::vector` 会自动分配一个新的、更大的连续内存块，并将现有元素复制或移动到这个新内存块中，然后释放原来的内存块。这通常以一种指数增长的方式进行，以便减少重新分配和复制的频率。
3. **使用分配器**：`std::vector` 使用一个分配器（默认是 `std::allocator`）来管理内存的分配和释放。通过这种方式，它可以灵活地获取和释放内存，同时保持数据在内存中的连续性。
4. **直接内存访问**：由于 `std::vector` 确保了内存的连续性，因此它提供了诸如 `data()` 方法，允许用户直接访问底层存储的指针。这使得它非常适合作为需要连续存储的应用场景，比如与C风格数组交互，或者需要高效的随机访问等场合。
5. **移动语义**：C++11及之后的标准支持移动语义，这允许 `std::vector` 在某些情况下（例如返回一个局部的 `std::vector` 或者将其作为参数传递）更高效地转移所有权而无需复制数据，这也间接帮助维持了元素的连续存储特性。
综上所述，`std::vector` 通过上述机制确保了元素的连续存储，从而提供了快速的随机访问能力和与C风格数组类似的性能特点。

# 3. 当vector空间不足时，如何扩容？
当 `std::vector` 中的空间不足以容纳更多元素时，它会自动进行扩容。这个过程通常涉及以下几个步骤：

1. **确定新容量**：当现有的容量不足以添加新的元素时，`std::vector` 会分配一个新的、更大的内存块。不同的实现可能使用不同的策略来决定新容量的大小，但一个常见的做法是将容量翻倍，或者按照某个增长因子（如1.5倍）来增加容量。这种几何级数的增长方式有助于减少多次重新分配的可能性，并且摊销了每次插入操作的成本。

2. **数据迁移**：一旦新的内存空间被分配，`std::vector` 会将其已有的元素从旧的存储区域复制或移动到新的存储区域。在C++11及之后的标准中，如果元素类型支持移动构造函数，那么可能会使用移动而非复制来提高效率和性能。

3. **释放旧内存**：在成功地将所有元素迁移到新的存储区域之后，`std::vector` 会释放之前使用的内存空间。

4. **更新内部指针和计数器**：最后，`std::vector` 更新其内部管理的指向数据起始位置的指针、当前大小以及容量等信息，以反映新的状态。

值得注意的是，扩容操作涉及到分配和释放内存以及复制或移动元素，这是一项相对昂贵的操作。因此，在预先知道需要存储多少元素的情况下，最好通过调用 `vector::reserve()` 方法提前预留足够的空间，这样可以避免不必要的扩容操作带来的性能损耗。

此外，如果你想要了解当前 `std::vector` 的容量而不想改变它的状态，可以使用 `capacity()` 方法；若想获取或修改当前存储的元素数量，则可以分别使用 `size()` 和 `resize()` 方法。这些方法可以帮助你更好地管理和优化 `std::vector` 的使用。


4. vector的push_back和emplace_back有什么区别？
- std::vector 的 emplace_back 函数确实用于在 容器的末尾插入一个新元素。
- emplace_back直接在 vector 的内存中构造新元素，而push_back先创建临时对象再复制/移动到容器中。

5. 使用vector需要注意哪些问题？
6. Vector有哪些应用场景？
7. list和vector有什么区别？
8. 为什么list没有push_front(&aff=25852)函数？
9. list如何实现元素的插入和删除？
10. map底层是如何实现的？
11. set 的底层是如何实现的？
12. map、set、multimap、multiset有什么区别？
13. 如何在map和set中查找元素？
14. unordered_map和map有什么区别？
15. 什么是迭代器，它有什么作用？
16. 五种迭代器类型分别是什么？
17. 什么是迭代器的失效？
18. 介绍一下STL中的算法库。
19. ind(&aff=25852)和binary_search(&aff=25852)有什么区别？
20. sort(&aff=25852)函数的实现原理是什么？
21. lower_bound(&aff=25852)和upper_bound(&aff=25852)有什么用处？
22. STL中的allocator有什么作用？
23. 什么是RAII原则，它在STL中如何应用？
24. 什么是智能指针，它有什么作用？
25. unique_ptr、shared_ptr和weak_ptr有什么区别？
26. 在什么情况下会选择使用智能指针？
27. 什么是adapter容器？
28. stack和queue底层是如何实现的？
29. priority_queue有什么应用场景？
30. string和stringstream有什么区别？
31. 如何使用stringstream进行字符串的格式化输出？
32. STL容器是线程安全的吗？
33. 如何在多线程环境下安全地使用STL？
34. 什么是泛型编程，它在STL中如何应用？
35. 函数对象和lambda表达式在STL中有什么作用？
36. 你如何选择合适的STL容器？
37. STL中的异常安全是什么，为什么重要？
38. C++11对STL有哪些改进？
39. 解释一下STL中的allocator-aware容器。
40. 如何自定义STL容器的比较函数？
41. 说一下你对STL中erase函数返回值的理解。
42. 描述一下你在使用STL过程中遇到的最大的挑战。
43. vector和array的使用场景分别是什么？
44. forward_list的特点和使用场景是什么？
45. unordered_map的哈希函数如何自定义？
46. 如何使用STL实现自定义数据结构的排序？比如自定义结构体。
47. 请谈谈对C++ STL的空间和时间复杂度的理解。
48. 在设计高性能的C++程序时，你会如何使用STL?
49. 请举出你使用STL解决过的实际问题。
50. STL中的算法是否都可以修改以适应并行计算？为什么？
51. 你如何看待STL中的异常处理机制？有何建议？
52. 对于C++20中引入的新STL特性，你了解多少？有何看法？
53. 在使用C++ STL的过程中，有没有遇到过因为语言特性或者编译器差异导致的问题？如何解决？
54. 如何评价STL在各种C++编程范式（过程式、面向对象、函数式）中的角色？
55. 如何利用STL实现数据的序列化和反序列化？
56. 你有没有对STL进行过定制或扩展？请谈谈你的经验和教训。
57. 使用STL的rope或者boost的string_ref有什么优点和缺点？
58. 请解释为什么在某些情况下，使用原生数组比使用STL的vector更好。
59. 如果你要在项目中推广STL的最佳实践，你会如何做？
60. 描述一次你有效地使用STL算法库中的某个函数解决问题的情况。
61. 你认为在未来，C++ STL会有怎样的发展趋势？
————————————————
