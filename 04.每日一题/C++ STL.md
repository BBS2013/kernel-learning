vector数据结构和数组非常相似，也称为**单端数组**,但是可以扩展。
List是双向链表，可以高效地进行插入和删除操作，但是不支持随机访问。



# 1. 请解释vector容器和它的特点。
* vector数据结构和**数组非常相似**，也称为**单端数组**,但是可以扩展。

# 2. vector如何保证元素的连续存储？
1. **初始化时分配内存**：当创建一个 `std::vector` 时，它会根据给定的大小或者默认构造函数决定的大小，请求分配一块足够大的连续内存空间来容纳初始数量的元素。
2. **自动扩容机制**：当你向 `std::vector` 中添加超过其当前容量的元素时，它需要更多的空间。此时，`std::vector` 会自动分配一个新的、更大的连续内存块，并将现有元素复制或移动到这个新内存块中，然后释放原来的内存块。这通常以一种指数增长的方式进行，以便减少重新分配和复制的频率。
3. **使用分配器**：`std::vector` 使用一个分配器（默认是 `std::allocator`）来管理内存的分配和释放。通过这种方式，它可以灵活地获取和释放内存，同时保持数据在内存中的连续性。
4. **直接内存访问**：由于 `std::vector` 确保了内存的连续性，因此它提供了诸如 `data()` 方法，允许用户直接访问底层存储的指针。这使得它非常适合作为需要连续存储的应用场景，比如与C风格数组交互，或者需要高效的随机访问等场合。
5. **移动语义**：C++11及之后的标准支持移动语义，这允许 `std::vector` 在某些情况下（例如返回一个局部的 `std::vector` 或者将其作为参数传递）更高效地转移所有权而无需复制数据，这也间接帮助维持了元素的连续存储特性。

# 3. 当vector空间不足时，如何扩容？
当 `std::vector` 中的空间不足以容纳更多元素时，它会自动进行扩容。这个过程通常涉及以下几个步骤：

1. **确定新容量**：当现有的容量不足以添加新的元素时，`std::vector` 会分配一个新的、更大的内存块。不同的实现可能使用不同的策略来决定新容量的大小，但一个常见的做法是将容量翻倍，或者按照某个增长因子（如1.5倍）来增加容量。这种几何级数的增长方式有助于减少多次重新分配的可能性，并且摊销了每次插入操作的成本。

2. **数据迁移**：一旦新的内存空间被分配，`std::vector` 会将其已有的元素从旧的存储区域复制或移动到新的存储区域。在C++11及之后的标准中，如果元素类型支持移动构造函数，那么可能会使用移动而非复制来提高效率和性能。

3. **释放旧内存**：在成功地将所有元素迁移到新的存储区域之后，`std::vector` 会释放之前使用的内存空间。

4. **更新内部指针和计数器**：最后，`std::vector` 更新其内部管理的指向数据起始位置的指针、当前大小以及容量等信息，以反映新的状态。

值得注意的是，扩容操作涉及到分配和释放内存以及复制或移动元素，这是一项相对昂贵的操作。因此，在预先知道需要存储多少元素的情况下，最好通过调用 `vector::reserve()` 方法提前预留足够的空间，这样可以避免不必要的扩容操作带来的性能损耗。

此外，如果你想要了解当前 `std::vector` 的容量而不想改变它的状态，可以使用 `capacity()` 方法；若想获取或修改当前存储的元素数量，则可以分别使用 `size()` 和 `resize()` 方法。这些方法可以帮助你更好地管理和优化 `std::vector` 的使用。

# 4.vector的push_back和emplace_back有什么区别？

- std::vector 的 emplace_back 函数确实用于在 容器的末尾插入一个新元素。
- emplace_back直接在 vector 的内存中构造新元素，而push_back先创建临时对象再复制/移动到容器中。



# 5.list和vector有什么区别？

List是双向链表。

```cpp
#include <iostream>
#include <vector>
#include <list>

int main() {
    // std::vector 示例
    std::vector<int> vec = {1, 2, 3};
    vec.push_back(4);          // 尾部插入
    vec.insert(vec.begin() + 1, 5);  // 中间插入
    std::cout << "Vector: ";
    for (int v : vec) std::cout << v << " ";  // 随机访问
    std::cout << std::endl;

    // std::list 示例
    std::list<int> lst = {1, 2, 3};
    lst.push_back(4);          // 尾部插入
    lst.insert(std::next(lst.begin()), 5);  // 中间插入
    std::cout << "List: ";
    for (int l : lst) std::cout << l << " ";  // 顺序访问
    std::cout << std::endl;

    return 0;
}
```



# 6.为什么list没有push_front(&aff=25852)函数？

`std::list` 的 `push_front` 函数用于在链表头部插入一个元素，其参数是一个 **值**（value），而非地址或引用。



7.list如何实现元素的插入和删除？

双向链表是有头有尾的元素。



# 8.map底层是如何实现的？

C++ 中 `std::map` 的底层实现基于 **红黑树（Red-Black Tree）**，这是一种自平衡的二叉搜索树。

set 的底层是如何实现的？
底层结构：红黑树（Red-Black Tree）

> 红黑树是一种满足以下特性的二叉搜索树：
>
> 1. **每个节点是红色或黑色**。
> 2. **根节点是黑色**。
> 3. **所有叶子节点（NIL节点）是黑色**。
> 4. **如果一个节点是红色，则它的两个子节点必须是黑色**（不能有两个连续的红色节点）。
> 5. **从任一节点到其每个叶子的所有路径都包含相同数量的黑色节点**。
>
> 这些特性确保了红黑树的 **高度接近 O(log⁡n)\*O\*(log\*n\*)**，从而保证插入、删除和查找操作的高效性。



# 9.map、set、multimap、multiset有什么区别？

在 C++ 中，`map`、`set`、`multimap` 和 `multiset` 是 STL 提供的四种**关联容器**，它们都基于 **红黑树**（平衡二叉搜索树）实现，支持高效的插入、查找和删除操作（时间复杂度为 $ O(\log n) $）。它们的主要区别在于**元素的组织方式**和**键值的唯一性**。以下是它们的详细对比：

| 特性            | `map`                      | `set`            | `multimap`                 | `multiset`    |
| --------------- | -------------------------- | ---------------- | -------------------------- | ------------- |
| **元素类型**    | `<key, value>`             | `value`          | `<key, value>`             | `value`       |
| **键唯一性**    | ✅                          | ✅                | ❌                          | ❌             |
| **插入重复键**  | 失败                       | 失败             | 成功                       | 成功          |
| **`[]` 操作符** | ✅                          | ❌                | ❌                          | ❌             |
| **元素修改**    | `key` 不可改，`value` 可改 | 不可改           | `key` 不可改，`value` 可改 | 不可改        |
| **查找效率**    | $ O(\log n) $              | $ O(\log n) $    | $ O(\log n) $              | $ O(\log n) $ |
| **适用场景**    | 键值对映射                 | 去重、存在性检查 | 一对多映射                 | 重复元素统计  |

---

### **如何选择？**
- **需要键值对**：优先选择 `map` 或 `multimap`。
- **需要唯一键**：使用 `map` 或 `set`。
- **允许重复键**：使用 `multimap` 或 `multiset`。
- **需要高效查找与排序**：选择基于红黑树的容器（如 `map`、`set`）。
- **需要无序但更快的查找**：使用 `unordered_map`、`unordered_set`（基于哈希表）。

通过理解这些容器的区别，可以更高效地根据实际需求选择合适的数据结构。



# 10.如何在map和set中查找元素？

find或count



# 11.unordered_map和map有什么区别？



# 12.什么是迭代器，它有什么作用？

在 C++ 中，**迭代器（